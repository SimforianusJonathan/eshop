<h1>WEEK 01 REFLECTION</h1>
<p>Berdasarkan tugas pemrograman lanjut dalam pembuatan website dengan framework javaspring untuk pertama kali, terdapat beberapa hal krusial yang dapat direfleksikan.
Dalam tutorial kali ini, diberikan petunjuk untuk menciptakan suatu gambaran awal website yang menyediakan objek model berupa produk yang mampu ditambahkan, diedit, dihapus, dan diperlihatkan di halaman website. Implementasi yang saya lakukan hanya pada bagian fitur edit dan hapus produk. Dari segi coding standard, saya rasa saya sudah mengimplementasikan beberapa komponen dengan baik dari standard 'Clean Code'.</p>

<p>Dimulai dari naming convention yang konsisten dengan penamaan variabel yang bermakna dan melambangkan deskripsi dan tipe data yang disimpan sehingga kode terlihat lebih sederhana dan mudah dimengerti. Serta konsistensi dalam penamaan variabel menggunakan camelCase, penamaan package yang lowercase, serta penamaan class / objek dengan PascalCase.</p>
<p>Function juga sudah terhandle dengan baik. Setiap function digunakan secara merata, setiap function dalam tiap file di package yang berbeda dibuat secara singkat dan efisien. Fungsi yang dibuat pun memiliki tujuan yang jelas dan minim efek samping yang menyulitkan programmer lain untuk membaca dan memahami kode tersebut. Nama dari funtion yang diberikan juga deskriptif sesuai dengan fungsionalitasnya.</p>
<p>Komentar pada kode juga telah dibuat dengan efisien yang cenderung menjelaskan sesuatu yang bersifat infromatif terhadap potongan kode di luar konteks utama sebagai deskripsi tahapan dalam kode. Komentar tidak dirancang menjadi bertele-tele atau redundan. Serta tidak terdapat kode yang mendeskripsikan suatu variabel (memenuhi naming convention di paragraf pertama). </p>
<p>Modifier-modifier khusus pada variabel sebagai atribut suatu struktur data class pun diperhatikan agar sesuaii fungsinya. Seperti objek model produk yang modifiernya dibuat menjadi private dengan getter dan setter, namun tetap transparan dengan modifier public pada class yang ebrsifat abstract seperti "interface"  yang ada di module 'service'. Karena modifier private cenderung digunakan untuk menyimpan data berharaga dan perlu transparansi untuk capability yang dapat dilakukan suatu class.</p>
<p>untuk error handling dan juga error logging telah dimmplementasi dengan baik terutama pada saat meminta input nama produk dan kuantitas produk. Dengan hanya menerima input valid berupa minimum 1 karakter non white space pada kolom nama produk dan wajib bilangan bulat posiitf untuk kuantitasnya. logging error pun disertakan dengan baik saat produk gagal dibuat atau di edit. 
Namun,program masih rentan penyerangan cyber yang masih belum verifikasi untuk input berupa script. Hal tersebut dapat digunakan sebagai celah untuk melakukan input script berupa penyerangan SQL injection, XSS(Cross Site Scripting), Command injection, RemoteCode Execution, dan lainnya.</p>

<p>Untuk bagian testing, saya merasa lebih percaya diri bahwa kode yang saya buat telah diverifikasi secara sistematis. Namun, menulis unit test juga membuat saya menyadari betapa pentingnya pendekatan yang terstruktur dan teliti dalam pengujian, karena ada banyak skenario yang perlu dipertimbangkan.
Menurut saya, dalam suatu class jumlah unit test yang dibutuhkan tergantung jumlah dari method yang ada serta jumlah condition yang terjadi dalam suatu method agar unit test coverage nya tinggi atau unit test dapat dianggap lebih valid. Dengan parameter code coverage, unit test seharusnya dapat memberikan verifikasi yang cukup optimal untuk memverfikasi program. Namun belum tentu kode program bebas dari error dan bug. Karena code coverage hanya mengukur kode yang dijalankan apakah sesuai dengan ekspetasi programmer / developer, namun tidak menentukan keabsahan logika dari program yang dirancang. Terdapat kemungkinan juga terdapat human error yang menyebabkan celah edge cases yang susah duntuk dianalisa. Selain itu, unit test juga merupakan test yang ebrsifat isolated dan belum berinteraksi dengan komponen lainnya. Sehingga masih belum mencakup keamanan dari bug dan error dalam skala besar.</p>
<p>Membuat functional test suite baru untuk verifikasi jumlah produk dalam halaman product list merupakan suatu hal yang efisien apabila dilakukan dengan benar. Namun terdapat beberapa masalah yang berpotensi muncul dari segi code cleanliness (mengurangi kualitas kode testing program) apabila menggunaan prosedur setup dan instans variabel yang sama.</p>
<p>1. Tidak efisien dan menyulitkan proses maintenance program (meningkatkan biaya maintenance) maupun menyebabkan readibility kode yang lumayan sulit bagi developer baru yang baru pertama kali mereview code tersebut.</p>
<p>2. Karena memiliki set up dan konfigurasi yang serupa, perubahan yang dilakukan pada setup kedua file apabila terjadi kesalahan atau revisi pada bagian konfigurasi / set up. Hal tersebut mengurangi fleksibilitas dalam testing dan terdapat potensi error simultan yang mungkin muncul dan perbaikan dilakukan simultan pula pada kedua file.</p>
<p>Alternatif untuk hal tersebut adalah dengan pembentukan base class (ex. abstract class) untuk setup procedures dan instance variables yang dapat digunakan untuk berbagai spesifikasi functional test tanpa terjadinya redundansi pada kode program. </p>

<h1>WEEK 02 REFLECTION</h1>
<p>1.Terdapat beberapa isu / masalah pada kode yang telah saya buat selama tutorial dan exercise sebelumnya. Berikut merupakan list masalah dan solusi yang saya lakukan untuk mengatasi hal tersebut :
<p>- Masalah terhadap kerapihan dalam grouping depedencies dalam konfigurasi buildgradle.kts = saya melakukan grouping berdasarkan kegunaan method (implementation, test, compile only, dev only, runtime only, annotate processor).
<p>- import modul yang tidak digunakan pada suatu file kode = Saya segera menghapus beberapa modul / library pada file yang awalnya dibutuhkan namun dialihkan menggunakan modul / library lain yang lupa untuk dihapus sebagai upaya menjaga kualitas kebersihan kode.
<p>- Menghapus statement yang kosong = Saya menghapus beberapa typo berupa simbol 'semikolon' yang menyatakan akhir dari suatu statement / line of code. Dalam kasus ini terdapat double semicolon sebagai bentuk typo yang perlu dihilangkan agar program java tidak membacanya sebagai empty statement dan menciptakan ambiguitas (walau secara runtime tidak terlalu signifikan).
<p>- Menghapus unit test yang kosong = Terdapat unit test bawaan dari framework java spring pada saat inisiasi projek awal. Hal tersebut dapat menganggu standar akurasi keberhasilan suatu unit test atau code coverage karena test yang tidak ada gunanya dianggap sebagai suatu uji kode yang berhasil.
<p>- Menambah dokumentasi pada setup unit test= Saya menambahkan dokumentasi pada bagian setup yang kosong pada suatu file unit test dengan tujuan memberikan suatu disclaimer / penjelasan bahwa  tets yang ingin dijalankan memiliki setup yang berbeda beda untuk tiap unit / bagian.
<p>- Menghapus exception throwing pada functional test bagian homepage = Hal tersebut tidak diperlukan karena JUnit5 / test dari jupiter sudah menghandle hal tersebut tanpa harus dideklarasi. Selain itu, metode yang dipanggil (driver.get(baseUrl) dan driver.getTitle()) tidak melemparkan pengecualian terperiksa (checked exception).
</p>

<p>2. Menurut saya pribdai, kode yang saya buat telah mengiplementasikan continous integration dan continous deployment dengan baik.
Dari sisi continous integration (CI), setiap push ke branch manapun atau pull request ke branch utama / main dilakukan di repository projek eshop, terdapat workflow yang bernama ci.yml yang berguna untuk melakukan pengujian terhadap setiap unit test yang ada di directory src/test.
Menjalankan unit tests menggunakan ./gradlew test dilakukan untuk memastikan kode tidak memiliki bug sebelum dimerge (karena projek ini menggunakan gradle untuk manajemen build,manajemen depedensi, dan melakukan tes secara motomatis).
Dari sisi continous deployment (CD), setiap melakukan push / merging ke branch main akan dilakukan re-deployment terhadap kode proyek pada Koyeb sebagai Platform as Service (PaaS).
Serta divalidasi terlebih dahulu keberhasilan dalam melakukan proses CI sebelum dilakuakn job deployment terhadap artefak yang berhasil di-build dan dites. </p>

<h1>WEEK 03 REFLECTION</h1>

<p>1. Dalam kode saya di minggu ke-3 ini. Saya sudah mengaplikasikan prinsip SOLID dalam kode progam. Berikut merupakan penjabarannya :</p>
<p>SRP (Single Responsibility Principle) telah saya aplikasikan dengan separasi yang jelas antar class berdasarkan tanggung jawab masing-masing. Seperti segmentasi class-class yang berhubungan / bertanggung jawab mengurus homepage, product, dan car yang dipecah dalam file-file berbeda baik untuk bagian repository(`CarRepository` & `ProductRepository`), service(`CarServiceImpl` & `ProductServiceImpl`), model(`Car` & `Product`), dan juga controller(`Car`, 'HomePage', & `Product`). Begitu juga untuk segmentasi pada bagian kode testing dengan cara yang sama.
<p>LSP (Liskov Substitution Principle) dilakukan dengan separasi yang terdapat dalam perubahan dari branch before-solid dan after-solid di mana pemisahan class untuk kontroler Produk dan Car yang awalnya berada di file yang sama,lalu dipecah menjadi `CarController.java` dan `ProductController.java`. Hal tersebut dilakukan karena tidak adanya keterkaitan antara class `CarController` untuk meng-inherit class 'ProductController' yang memiliki tanggung jawab tersendiri untuk mengurus yang terkait dengan class Product dan class Car.</p>
<p>OCP (Open Close Principle) dilakukan dengan menciptakan suatu method khusus pada model Car dengan menambahkan methhod `Update()` sehingga subclass tidak perlu melakukan perubahan 'behaviour'. Namun tinggal melakukan overriding method superclass.</p>
<p>ISP (Interface Seggregation Principle) telah dilakukan dalam pemecahan class interface untuk model Car dan juga Product sehingga tidak perlu melakukan implementasi method yang tidak diperlukan service (tidak berhubungan dengan objek model yang ingin fokus di-develop servisnya).</p>
<p>DI (Depedency Inversion) adalah yang terakhir dan telah dimplementasikan. Contohnya terlihat pada bagian class `CarController.java` yang awalnya menjadikan implementasi servisnya (`CarServiceImpl.jav`) sebagai object service pada controller. Seharusnya high-level module bergantung kepada abstarksi yang lebih general dibanding implementasi. Hal trsebut dengan mengganti depedensi dengan `CarService` saja.</p>

<p>2. Keuntungan implementasi SOLID Principle pada kode program saya, antara lain :</p>
<p>- SRP= Setiap class yanng memiliki tanggung jawab tersendiri sehingga mengurangi kompleksitas kode dan berpengaruh pada saat melakukan baik tahap develop maupaun maintenance (debugging juga). Sehingga memudahkan fokus masalah / responsibility  yang ingin di resolve.</p>
<p>- LSP= Menjaga intergritas dari program dengan memastikan setiap subclass dari suatu parent class mampu melakukan hal yang sama (bahkan dengan spesifkasi lebih). Walaupun belum ada subclass di program saya, namun jika ingin menambahkan, prinsip ini mampu berguna. Namun apabila subclass dan superclass bahkan tidak berhubungan sama sekali, ada baiknya dilakukan separasi seperti yang telah saya lakukan sebelumnya.</p>
<p>- OCP= Hal tersebut dapat membantu juga pada saat developing subclass tanpa harus melakukan modifikasi pada class yang sudah ada (super classnya). Hal ini berguna jika saya ingin menegmbangkan program saya lagi dengan model baru yang diperlukan dan merupakan subclass yang sudah ada.</p>
<p>- ISP= Hal ini berguna terutama pada implementasi dari interface untuk Car dan Product yang dibuat terpisah sehingga implementasi keduanya menjadi efisien tanpa harus implementasi method yang tidak berhubungan satu sama lain karena penggabungan method dalam interface yang sama.</p>
<p>- DI= Hal ini berguna pada kemudahan dalam maintenance kode terutama apabila ingin dilakukan perubahan. Contohnya bila pada `CarController.java` yang awalnya menggunakan impelmentasi service car. Jika kita ingin mengganti dengan implementasi lain untuk testing contohnya menggunakan `CarServiceMock`, maka tidak perlu mengubah kode dalam `CarController.java` apabila sejak awal bergantung dengan modul interface nya car service yaitu `CarService.java`</p>
<p>Hal ini berpengaruh pada maintainability yang lebih mudah dan efisien, kode yang lebih fleksibel, skalabilitas yang baik, readability yang lebih mudah, dan juga testability yang lebih mudah karena segmentasi kode yang baik. </p>

<p>3. Kekurangan yang terjadi pada projek saya apabila tidak diterapkan prinsip SOLID adalah kebalikan dari kelebihannya tadi. Dimulai dari proses maintenance kode yang lebih sulit apabila tidak dilakukan pembagian tanggung jawab yang sesuai pada tiap class baik class, sehingga menyulitkan developer dalam menemukan fitur yang ingin dikoreksi. Testability yang cenderung kurang baik karena fungsionalitas antara berbagai objek model yang saling bercampur sehingga menyulitkan dalam prosesnya.Jika ada interface besar yang mencakup banyak fungsi yang tidak selalu digunakan, class yang mengimplementasikannya akan terbebani dengan metode yang tidak relevan. Terdapat kesulitan juga apabila ingin melakukan substitusi terhadap depedensi yang dinggunakan antar kode apabila tidak menggunakan depedensi dengan modul abstaraksi. Serta perubahan kecil pada kode yang mungkin salah mampu berdampak buruk dan lumayan besar pada kode program karena integrasi kode yang kurang baik serta segmentasi yang tidak struktural. 
Contohnya pada branch `before-solid` yang awalnya menghubungkan controller dengan `CarServiceImpl.java` tanpa mempertimbangkan apabila ingin dilakukan pergantian pada  maka kita tidak bisa mengganti implementasi tanpa mengubah kode controller yang berdampak pada kesulitan pengujian karena tidak bisa menggunakan mock/fake untuk `CarService`.  </p>